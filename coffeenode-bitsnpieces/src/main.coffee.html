<!doctype html>

<!-- Documentation generated by [CoffeeDoc](http://github.com/omarkhan/coffeedoc) -->

<html>
<head>
  <title>CoffeeDoc | main.coffee</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" media="all" href="../resources/base.css" />
</head>
<body>
  <header>
    <h1>main.coffee</h1>
  </header>
  <div class="container">
    <div class="sidebar column">
      
      
      <h4>Functions</h4>
      <ul class="functionlist">
        
        <li><a href="#this.equals">this.equals</a></li>
        
        <li><a href="#this.format_number">this.format_number</a></li>
        
        <li><a href="#this.escape_regex">this.escape_regex</a></li>
        
        <li><a href="#this.escape_html">this.escape_html</a></li>
        
        <li><a href="#this.get_rnd">this.get_rnd</a></li>
        
        <li><a href="#validate_isa_number">validate_isa_number</a></li>
        
        <li><a href="#this.pluck">this.pluck</a></li>
        
        <li><a href="#this.get_parent_routes">this.get_parent_routes</a></li>
        
        <li><a href="#this.get_V8_CallSite_objects">this.get_V8_CallSite_objects</a></li>
        
        <li><a href="#this.get_caller_info_stack">this.get_caller_info_stack</a></li>
        
        <li><a href="#this.get_caller_routes">this.get_caller_routes</a></li>
        
        <li><a href="#this.get_filtered_caller_routes">this.get_filtered_caller_routes</a></li>
        
        <li><a href="#this.create_id">this.create_id</a></li>
        
        <li><a href="#this.create_random_id">this.create_random_id</a></li>
        
        <li><a href="#this.get_create_rnd_id">this.get_create_rnd_id</a></li>
        
        <li><a href="#this.id_from_text">this.id_from_text</a></li>
        
        <li><a href="#this.get_app_home">this.get_app_home</a></li>
        
        <li><a href="#this.compile_options">this.compile_options</a></li>
        
        <li><a href="#this.compile_options.resolve_name">this.compile_options.resolve_name</a></li>
        
        <li><a href="#this.walk_containers_crumbs_and_values">this.walk_containers_crumbs_and_values</a></li>
        
        <li><a href="#this._walk_containers_crumbs_and_values">this._walk_containers_crumbs_and_values</a></li>
        
        <li><a href="#this._walk_list_crumbs_and_values">this._walk_list_crumbs_and_values</a></li>
        
        <li><a href="#this._walk_pod_crumbs_and_values">this._walk_pod_crumbs_and_values</a></li>
        
        <li><a href="#this.container_and_facet_from_locator">this.container_and_facet_from_locator</a></li>
        
        <li><a href="#this.container_and_facet_from_crumbs">this.container_and_facet_from_crumbs</a></li>
        
        <li><a href="#this._container_and_facet_from_crumbs">this._container_and_facet_from_crumbs</a></li>
        
      </ul>
      
    </div>
    <div class="content column">
      
      
      
      <div id="functions">
        <h2>Functions</h2>
        
        <div class="function">
          <div class="header">
            <a id="this.equals"><h3>this.equals(a, b)</h3></a>
          </div>
          
          <div>
            <p><code>equals</code> is a shim for accessing the NodeJS <code>assert.deepEqual</code> method. Use it for PODs and lists. </p>

          </div>
          
        </div>
        
        <div class="function">
          <div class="header">
            <a id="this.format_number"><h3>this.format_number(n)</h3></a>
          </div>
          
          <div>
            <p>A simple number formatter. </p>

          </div>
          
        </div>
        
        <div class="function">
          <div class="header">
            <a id="this.escape_regex"><h3>this.escape_regex(text)</h3></a>
          </div>
          
          <div>
            <p> Given a <code>text</code>, return the same with all regular expression metacharacters properly escaped. Escaped
characters are <code>[]{}()*+?-.,\^$|#</code> plus whitespace. </p>

          </div>
          
        </div>
        
        <div class="function">
          <div class="header">
            <a id="this.escape_html"><h3>this.escape_html(text)</h3></a>
          </div>
          
          <div>
            <p> Given a <code>text</code>, return the same with all characters critical in HTML (<code>&amp;</code>, <code>&lt;</code>, <code>&gt;</code>) properly
escaped. </p>

          </div>
          
        </div>
        
        <div class="function">
          <div class="header">
            <a id="this.get_rnd"><h3>this.get_rnd(seed, delta)</h3></a>
          </div>
          
          <div>
            <p> This method returns a simple deterministic pseudo-random number generator—basically like
<code>Math.random</code>, but (1) very probably with a much worse distribution of results, and (2) with predictable
series of numbers, which is good for some testing scenarios. You may seed this method by passing in a
<code>seed</code> and a <code>delta</code>, both of which must be non-zero numbers; the ensuing series of calls to the returned
method will then always result in the same series of numbers. Here is a usage example that also shows how
to reset the generator:</p>
<pre><code>BAP = <span class="keyword">require</span> <span class="string">'coffeenode-bitsnpieces'</span>
rnd = BAP.get_rnd() <span class="comment"># or, say, `rnd = BAP.get_rnd 123, 0.5`</span>
log BAP.rnd() <span class="keyword">for</span> idx in [ <span class="number">0</span> .. <span class="number">5</span> ]
log()
rnd.reset()
log BAP.rnd() <span class="keyword">for</span> idx in [ <span class="number">0</span> .. <span class="number">5</span> ]
</code></pre><p>Please note that there are no strong guarantees made about the quality of the generated values except the
(1) deterministic repeatability, (2) boundedness, and (3) &#39;apparent randomness&#39;. Do <strong>not</strong> use this for
cryptographic purposes. </p>

          </div>
          
        </div>
        
        <div class="function">
          <div class="header">
            <a id="validate_isa_number"><h3>validate_isa_number(x)</h3></a>
          </div>
          
        </div>
        
        <div class="function">
          <div class="header">
            <a id="this.pluck"><h3>this.pluck(x, name, fallback)</h3></a>
          </div>
          
          <div>
            <p> Given some object <code>x</code>, a <code>name</code> and a <code>fallback</code>, return the value of <code>x[ name ]</code>, or, if it does not
exist, <code>fallback</code>. When the method returns, <code>x[ name ]</code> has been deleted. </p>

          </div>
          
        </div>
        
        <div class="function">
          <div class="header">
            <a id="this.get_parent_routes"><h3>this.get_parent_routes(route)</h3></a>
          </div>
          
        </div>
        
        <div class="function">
          <div class="header">
            <a id="this.get_V8_CallSite_objects"><h3>this.get_V8_CallSite_objects(delta)</h3></a>
          </div>
          
          <div>
            <p>Save original Error.prepareStackTrace </p>

          </div>
          
        </div>
        
        <div class="function">
          <div class="header">
            <a id="this.get_caller_info_stack"><h3>this.get_caller_info_stack(delta)</h3></a>
          </div>
          
        </div>
        
        <div class="function">
          <div class="header">
            <a id="this.get_caller_routes"><h3>this.get_caller_routes(delta)</h3></a>
          </div>
          
        </div>
        
        <div class="function">
          <div class="header">
            <a id="this.get_filtered_caller_routes"><h3>this.get_filtered_caller_routes(delta)</h3></a>
          </div>
          
        </div>
        
        <div class="function">
          <div class="header">
            <a id="this.create_id"><h3>this.create_id(values, length)</h3></a>
          </div>
          
          <div>
            <p> Given a number of <code>values</code> and a <code>length</code>, return an ID with <code>length</code> hexadecimal digits (<code>[0-9a-f]</code>)
that deterministically depends on the input but can probably not reverse-engeneered to yield the input
values. This is in no way meant to be cryptographically strong, just arbitrary enough so that we have a
convenient method to derive an ID with little chance of overlap given different inputs. <strong>Note</strong> It is
certainly possible to use this method (or <code>id_from_text</code>) to create a hash from a password to be stored in
a DB. Don&#39;t do this. Use <code>bcrypt</code> or similar best-practices for password storage. Again, the intent of
the BITSNPIECES ID utilities is <em>not</em> to be &#39;crypto-safe&#39;; its intent is to give you a tool for generating
repetition-free IDs. </p>

          </div>
          
        </div>
        
        <div class="function">
          <div class="header">
            <a id="this.create_random_id"><h3>this.create_random_id(values, length)</h3></a>
          </div>
          
          <div>
            <p> Like <code>create_id</code>, but with an extra random factor built in that should exclude that two identical
outputs are ever returned for any two identical inputs. Under the assumption that two calls to this
method are highly unlikely two produce an identical pair <code>( 1 * new Date(), Math.random() )</code> (which could
only happen if <code>Math.random()</code> returned the same number again <em>within the same clock millisecond</em>), and
assuming you are using a reasonable value for <code>length</code> (i.e., say, <code>7 &lt; length &lt; 20</code>), you should never
see the same ID twice. </p>

          </div>
          
        </div>
        
        <div class="function">
          <div class="header">
            <a id="this.get_create_rnd_id"><h3>this.get_create_rnd_id(seed, delta)</h3></a>
          </div>
          
          <div>
            <p> Given an optional <code>seed</code> and <code>delta</code>, returns a function that will create pseudo-random IDs similar to
the ones <code>create_random_id</code> returns; however, the Bits&#39;n&#39;Pieces <code>get_rnd</code> method is used to obtain a
repeatable random number generator so that ID sequences are repeatable. The underlying PRNG is exposed as
<code>fn.rnd</code>, so <code>fn.rnd.reset</code> may be used to start over.</p>
<p><strong>Use Case Example</strong>: The below code demonstrates the interesting properties of the method returned by
<code>get_create_rnd_id</code>: <strong>(1)</strong> we can seed the PRNG with numbers of our choice, so we get a chance to create
IDs that are unlikely to be repeated by other people using the same software, even when later inputs (such
as the email adresses shown here) happen to be the same. <strong>(2)</strong> Calling the ID generator with three
diffferent user-specific inputs, we get three different IDs, as expected. <strong>(3)</strong> Repeating the ID
generation calls with the <em>same</em> arguments will yield <em>different</em> IDs. <strong>(4)</strong> After calling
<code>create_rnd_id.rnd.reset()</code> and feeding <code>create_rnd_id</code> with the <em>same</em> user-specific inputs, we can still
see the identical <em>same</em> IDs generated—which is great for testing.</p>
<pre><code>create_rnd_id = BAP.get_create_rnd_id <span class="number">1234</span>, <span class="number">87.23</span>

<span class="comment"># three different user IDs:</span>
log create_rnd_id [ <span class="string">'foo@example.com'</span> ], <span class="number">12</span>
log create_rnd_id [ <span class="string">'alice@nosuchname.com'</span> ], <span class="number">12</span>
log create_rnd_id [ <span class="string">'tim@cern.ch'</span> ], <span class="number">12</span>

<span class="comment"># the same repeated, but yielding random other IDs:</span>
log()
log create_rnd_id [ <span class="string">'foo@example.com'</span> ], <span class="number">12</span>
log create_rnd_id [ <span class="string">'alice@nosuchname.com'</span> ], <span class="number">12</span>
log create_rnd_id [ <span class="string">'tim@cern.ch'</span> ], <span class="number">12</span>

<span class="comment"># the same repeated, but yielding the same IDs as in the first run:</span>
log()
create_rnd_id.rnd.reset()
log create_rnd_id [ <span class="string">'foo@example.com'</span> ], <span class="number">12</span>
log create_rnd_id [ <span class="string">'alice@nosuchname.com'</span> ], <span class="number">12</span>
log create_rnd_id [ <span class="string">'tim@cern.ch'</span> ], <span class="number">12</span>
</code></pre><p>The output you should see is</p>
<pre><code>c40f774fce65
9d44f31f9a55
1b26e6e3e736

a0e11f616685
d7242f6935c7
976f26d1b25b

c40f774fce65
9d44f31f9a55
1b26e6e3e736
</code></pre><p>Note the last three IDs exactly match the first three IDs. The upshot of this is that we get reasonably
hard-to-guess, yet on-demand replayable IDs. Apart from weaknesses in the PRNG itself (for which see the
caveats in the description to <code>get_rnd</code>), the obvious way to cheat the system is by making it so that
a given piece of case-specific data is fed into the ID generator as the n-th call a second time. In
theory, we could make it so that each call constributes to the state change inside of <code>create_rnd_id</code>;
a replay would then need to provide all of the case-specific pieces of data a second time, in the right
order. </p>

          </div>
          
        </div>
        
        <div class="function">
          <div class="header">
            <a id="this.id_from_text"><h3>this.id_from_text(text, length)</h3></a>
          </div>
          
          <div>
            <p> Given a <code>text</code> and a <code>length</code>, return an ID with <code>length</code> hexadecimal digits (<code>[0-9a-f]</code>)—this is like
<code>create_id</code>, but working on a text rather than a number of arbitrary values. The hash algorithm currently
used is SHA-1, which returns 40 hex digits; it should be good enough for the task at hand and has the
advantage of being widely implemented. </p>

          </div>
          
        </div>
        
        <div class="function">
          <div class="header">
            <a id="this.get_app_home"><h3>this.get_app_home(routes)</h3></a>
          </div>
          
          <div>
            <p> Return the file system route to the current (likely) application folder. This works by traversing all
the routes in <code>require[ &#39;main&#39; ][ &#39;paths&#39; ]</code> and checking whether one of the <code>node_modules</code> folders
listed there exists and is a folder; the first match is accepted and returned. If no matching existing
route is found, an error is thrown.</p>
<p>NB that the algorithm works even if the CoffeeNode Options module has been symlinked from another location
(rather than &#39;physically&#39; installed) and even if the application main file has been executed from outside
the application folder (i.e. this obviates the need to <code>cd ~/route/to/my/app</code> before doing <code>node ./start</code>
or whatever—you can simply do <code>node ~/route/to/my/app/start</code>), but it does presuppose that (1) there <em>is</em>
a <code>node_modules</code> folder in your app folder; (2) there is <em>no</em> <code>node_modules</code> folder in the subfolder or
any of the intervening levels (if any) that contains your startup file. Most modules that follow the
established NodeJS / npm way of structuring modules should naturally comply with these assumptions. </p>

          </div>
          
        </div>
        
        <div class="function">
          <div class="header">
            <a id="this.compile_options"><h3>this.compile_options(options)</h3></a>
          </div>
          
        </div>
        
        <div class="function">
          <div class="header">
            <a id="this.compile_options.resolve_name"><h3>this.compile_options.resolve_name(options, container, key, value)</h3></a>
          </div>
          
        </div>
        
        <div class="function">
          <div class="header">
            <a id="this.walk_containers_crumbs_and_values"><h3>this.walk_containers_crumbs_and_values(value, handler)</h3></a>
          </div>
          
          <div>
            <p> Given a <code>value</code> and a <code>handler</code> with the signature <code>( error, container, crumbs, value )</code>, this method
will call <code>handler null, container, crumbs, value</code> for each &#39;primitive&#39; sub-value (&#39;leaf value&#39;) that is
found inside of <code>value</code>, where <code>container</code> is the list or POD that contains <code>value</code>, and <code>crumbs</code> is a
(possibly empty) list of names that, when transformed as <code>&#39;/&#39; + crumbs.join &#39;/&#39;</code>, spells out the locator
where <code>value</code> was found. When <code>crumbs</code> is not empty, its last element will be the index (in case of a
list) or the name (in case of a POD) where <code>value</code> was found.</p>
<p>When iteration is done, the method will make one additional call with all arguments set to <code>null</code>;
consumers are able to detect that iteration has terminated by testing for <code>crumbs is null</code>.</p>
<p>An <strong>example</strong> will show better what&#39;s happening:</p>
<pre><code class="lang-coffee">d =
  meaningless: [
    <span class="number">42</span>
    <span class="number">43</span>
    { foo: <span class="number">1</span>, bar: <span class="number">2</span>, nested: [ <span class="string">'a'</span>, <span class="string">'b'</span>, ] }
    <span class="number">45</span> ]
  deep:
    down:
      in:
        a:
          drawer:   <span class="string">'a pen'</span>
          cupboard: <span class="string">'a pot'</span>
          box:      <span class="string">'a pill'</span>

BAP.walk_containers_crumbs_and_values d, ( error, container, crumbs, value ) ->
  <span class="keyword">throw</span> error <span class="keyword">if</span> error?
  <span class="keyword">if</span> crumbs is <span class="keyword">null</span>
    log <span class="string">'over'</span>
    <span class="keyword">return</span>
  locator           = <span class="string">'/'</span> + crumbs.join <span class="string">'/'</span>
  <span class="comment"># in case you want to mutate values in a container, use:</span>
  [ head..., key, ] = crumbs
  log <span class="string">"#{locator}:"</span>, rpr value
</code></pre>
<p>Output:</p>
<pre><code>/meaningless/0: 42
/meaningless/1: 43
/meaningless/2/foo: 1
/meaningless/2/bar: 2
/meaningless/2/nested/0: &#39;a&#39;
/meaningless/2/nested/1: &#39;b&#39;
/meaningless/3: 45
/deep/down/in/a/drawer: &#39;a pen&#39;
/deep/down/in/a/cupboard: &#39;a pot&#39;
/deep/down/in/a/box: &#39;a pill&#39;
over
</code></pre><p>As can be seen, there are no callbacks made for values that are lists or PODs, only for primitive values
(or objects that are no lists and no PODs). Keep in mind that some JavaScript objects may <em>look</em> like PODs
or lists, but are really something different. As the primary use case for this method is analysis of
nested configurations read from a JSON file, such complexities have not been considered in the design of
this method.</p>
<p>You may pass a single primitive value to <code>@walk_containers_crumbs_and_values</code>; this will result in a
callback where <code>crumbs</code> is an empty list and <code>value</code> is the value you passed in.</p>
<p><strong>Caveats:</strong></p>
<p>Because of the way iteration happens in CoffeeScript and JavaScript, it&#39;s not a good idea to modify the
containers you&#39;re currently iterating over. <a href="">MDN</a> has the following to say:</p>
<blockquote>
<p>If a property is modified in one iteration and then visited at a later time, its value in the loop is
its value at that later time. A property that is deleted before it has been visited will not be visited
later. Properties added to the object over which iteration is occurring may either be visited or omitted
from iteration. <strong>In general it is best not to add, modify or remove properties from the object during
iteration, other than the property currently being visited.</strong> There is no guarantee whether or not an
added property will be visited, whether a modified property (other than the current one) will be visited
before or after it is modified, or whether a deleted property will be visited before it is deleted.</p>
</blockquote>
<p><strong>Therefore, if deeper modifications are necessary, you may want to do those on a copy of the object
you&#39;re inspecting, or else keep a log of intended changes and execute those changes when iteration has
stopped.</strong></p>
<p>The <code>crumbs</code> list in the callback is always the same object, so in case you want to use the values
elsewhere—and especially when used in an asynchronous fashion—you may want to make a copy of that list.</p>
<p>The method currently makes no effort to respect bad naming choices in any way, which means that you may
get faulty or troublesome locators in case names are empty, consist of single or double periods, or
contain slashes, asterisks or other meta-characters.</p>

          </div>
          
        </div>
        
        <div class="function">
          <div class="header">
            <a id="this._walk_containers_crumbs_and_values"><h3>this._walk_containers_crumbs_and_values(container, crumbs, value, handler)</h3></a>
          </div>
          
          <div>
            <p>( used by @<a href="#this.walk_containers_crumbs_and_values"><code>walk_containers_crumbs_and_values</code></a>) </p>

          </div>
          
        </div>
        
        <div class="function">
          <div class="header">
            <a id="this._walk_list_crumbs_and_values"><h3>this._walk_list_crumbs_and_values(container, crumbs, list, handler)</h3></a>
          </div>
          
          <div>
            <p>( used by @<a href="#this.walk_containers_crumbs_and_values"><code>walk_containers_crumbs_and_values</code></a>) </p>

          </div>
          
        </div>
        
        <div class="function">
          <div class="header">
            <a id="this._walk_pod_crumbs_and_values"><h3>this._walk_pod_crumbs_and_values(container, crumbs, pod, handler)</h3></a>
          </div>
          
          <div>
            <p>( used by @<a href="#this.walk_containers_crumbs_and_values"><code>walk_containers_crumbs_and_values</code></a>) </p>

          </div>
          
        </div>
        
        <div class="function">
          <div class="header">
            <a id="this.container_and_facet_from_locator"><h3>this.container_and_facet_from_locator(container, locator)</h3></a>
          </div>
          
          <div>
            <p> The inverse to @<a href="#this.walk_containers_crumbs_and_values"><code>walk_containers_crumbs_and_values</code></a>, this
method uses a <code>locator</code> to drill down into <code>container</code>, recursively applying the &#39;crumbs&#39; (parts) of
the <code>locator</code> until all of the locator has been consumed; it will then return a triplet <code>[ sub_container,
key, value, ]</code>.</p>
<p>The locator must either be the string <code>/</code> (which denotes the <code>container</code> itself) or else a string that
starts with but does not end with a <code>/</code>. </p>

          </div>
          
        </div>
        
        <div class="function">
          <div class="header">
            <a id="this.container_and_facet_from_crumbs"><h3>this.container_and_facet_from_crumbs(container, crumbs)</h3></a>
          </div>
          
          <div>
            <p> Same as @<a href="#this.container_and_facet_from_locator"><code>container_and_facet_from_locator</code></a>, but accepting
a list of crumbs instead of a locator. </p>

          </div>
          
        </div>
        
        <div class="function">
          <div class="header">
            <a id="this._container_and_facet_from_crumbs"><h3>this._container_and_facet_from_crumbs(container, locator, crumbs, idx)</h3></a>
          </div>
          
          <div>
            <p> (used by @<a href="#this.container_and_facet_from_locator"><code>container_and_facet_from_locator</code></a> and
@<a href="#this.container_and_facet_from_crumbs"><code>container_and_facet_from_crumbs</code></a>)</p>

          </div>
          
        </div>
        
        
          
        
      </div>
      
    </div>
  </div>
</body>
</html>
